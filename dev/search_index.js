var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Author = \"Jakob Assländer\"\nCurrentModule = MRIeddyCurrentOptimization","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of all exported functions of the MRIeddyCurrentOptimization.jl package:","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MRIeddyCurrentOptimization]","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JakobAsslaender/MRIeddyCurrentOptimization.jl/blob/master/docs/src/tutorial.jl\"","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"build_literate/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"The core of generalized Bloch model is implemented in the function apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t), which calculates the derivative ∂m/∂t for a given magnetization vector m and stores it in-place in the the variable ∂m∂t. The function interface is written in a way that we can directly feed it into a differential equation solver of the DifferentialEquations.jl package.","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"For this example, we need the following packages:","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"using MRIeddyCurrentOptimization\nusing BenchmarkTools\nusing LinearAlgebra\nusing Random","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"Define number of flip angles and cycles","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"nFA = 571\nnCyc = 872;\nnothing #hide","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate 2D golden means","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"s, v = eigen([0 1 0; 0 0 1; 1 0 1])\nGA1 = real(v[1,end] / v[end,end])","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"second one","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"GA2 = real(v[2,end] / v[end,end])","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"set up 3D radial koosh ball trajectory","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"theta = acos.(((0:(nCyc * nFA - 1)) * GA1) .% 1)\nphi = Float64.(0:(nCyc * nFA - 1)) * 2 * pi * GA2\n\ntheta = reshape(theta, nCyc, nFA)\nphi   = reshape(phi, nCyc, nFA)\ntheta = vec(theta)\nphi   = vec(phi)\n\nk = zeros(3, length(theta))\nk[3,:] = cos.(theta)\nk[2,:] = sin.(theta) .* sin.(phi)\nk[1,:] = sin.(theta) .* cos.(phi)\n\nk = reshape(k, 3, nCyc, nFA)\nk = permutedims(k, (1, 3, 2))\nkv = reshape(k, 3, nCyc*nFA);\nnothing #hide","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"Set number of iterations","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"N = 10_000_000","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"initalize with linear order","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"order = Int32.(1:(nCyc*nFA))\norder = reshape(order, nFA, nCyc)","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate initial cost","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"MRIeddyCurrentOptimization.cost(kv,order)","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"call simulated annealing algorithm that changes the order in place (as indicated by the ! at the end of the function call)","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"SimulatedAnneling!(kv, order, N, nFA, nCyc)","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate the final cost","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"MRIeddyCurrentOptimization.cost(kv,order)","category":"page"},{"location":"build_literate/tutorial/#Benchmarking","page":"Tutorial","title":"Benchmarking","text":"","category":"section"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"N = 1_000\n@benchmark SimulatedAnneling!($kv, $order, $N, $nFA, $nCyc, rng = $(MersenneTwister(12345)))","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MRIeddyCurrentOptimization","category":"page"},{"location":"#MRIeddyCurrentOptimization.jl","page":"Home","title":"MRIeddyCurrentOptimization.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the MRIeddyCurrentOptimization.jl package, which implements ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation of all exported functions can be found in the API Section. ","category":"page"}]
}
