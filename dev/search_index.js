var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Author = \"Jakob Assländer\"\nCurrentModule = MRIeddyCurrentOptimization","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of all exported functions of the MRIeddyCurrentOptimization.jl package:","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MRIeddyCurrentOptimization]","category":"page"},{"location":"api/#MRIeddyCurrentOptimization.SimulatedAnneling!-Tuple{Any, Any}","page":"API","title":"MRIeddyCurrentOptimization.SimulatedAnneling!","text":"SimulatedAnneling!(k, order[;N_iter=1_000_000_000, p=3, w_even=1, rng = MersenneTwister(12345), verbose = false])\n\nPerforms the simulated annealing algorith and writes the result in-place in order and returns order for convenience.\n\nArguemnts\n\nk::Matrix{Number}: 3 x N_spokes matrix containing the [x,y,z] coordinates of the first data point of each spoke\norder::Matrix{Int}: nFA x nCyc matrix containing the indices in which the spokes in k are acquired. This matrix is overwritten by the algorithm with the optimized index matrix. \n\nOptional:\n\nN_iter::Int: Number of iterations. The default is 1e9\nT2s_max::Number: upper bound of the T2s range in seconds\np::Number: exponent to scale the squared-Euclidean distance. Default is p=3, which is equivalent to p=6 in the paper, as the Euclidean distance is already squared. \nw_even::Number: weighting factor of the even jumps. The default is w_even=1 which weights even and odd equally. Choose w_even=0 for Bieri's paring approch. \nrng: seed for the random number generator. The default is rng = MersenneTwister(12345). Use a different seed when repeating the algorithm for a different outcome. \nverbose::Boolean: by default this flag is false and no output is printed. When set to true, the algorithm prints the cost at each full percent of runtime.\n\nExamples\n\njulia> using MRIeddyCurrentOptimization\n\njulia> nFA  = 10;\n\njulia> nCyc = 5;\n\njulia> theta = acos.(((0:(nCyc * nFA - 1)) * 0.46557) .% 1);\n\njulia> phi = Float64.(0:(nCyc * nFA - 1)) * 2 * pi * 0.6823;\n\njulia> k = zeros(3, length(theta));\n\njulia> k[3,:] = cos.(theta);\n\njulia> k[2,:] = sin.(theta) .* sin.(phi);\n\njulia> k[1,:] = sin.(theta) .* cos.(phi);\n\njulia> k = reshape(k, 3, nCyc, nFA);\n\njulia> k = permutedims(k, (1, 3, 2));\n\njulia> k = reshape(k, 3, nCyc*nFA)\n3×50 Matrix{Float64}:\n 1.0          -0.802397   0.334292  …  -0.762115  0.866723  -0.531067\n 0.0           0.498671  -0.676983     -0.62806   0.116138   0.238983\n 6.12323e-17   0.32785    0.6557        0.15723   0.48508    0.81293\n\njulia> order = reshape(Int32.(1:(nCyc*nFA)), nFA, nCyc)\n10×5 Matrix{Int32}:\n  1  11  21  31  41\n  2  12  22  32  42\n  3  13  23  33  43\n  4  14  24  34  44\n  5  15  25  35  45\n  6  16  26  36  46\n  7  17  27  37  47\n  8  18  28  38  48\n  9  19  29  39  49\n 10  20  30  40  50\n\njulia> SimulatedAnneling!(k, order; N_iter=10)\n10×5 Matrix{Int32}:\n  1  11  21  31  41\n  2  22  12  32  42\n 13   3  43  33  23\n  4  14  24  34  44\n  5  15  25  35  45\n 36  46  26   6  16\n  7  17  27  37  47\n  8  18  28  38  48\n  9  19  29  39  49\n 10  20  40  30  50\n\n\n\n\n\n\n","category":"method"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JakobAsslaender/MRIeddyCurrentOptimization.jl/blob/master/docs/src/tutorial.jl\"","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"build_literate/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"The core of generalized Bloch model is implemented in the function apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t), which calculates the derivative ∂m/∂t for a given magnetization vector m and stores it in-place in the the variable ∂m∂t. The function interface is written in a way that we can directly feed it into a differential equation solver of the DifferentialEquations.jl package.","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"For this example, we need the following packages:","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"using MRIeddyCurrentOptimization\nusing BenchmarkTools\nusing LinearAlgebra\nusing Random","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"Define number of flip angles and cycles","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"nFA = 571\nnCyc = 872;\nnothing #hide","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate 2D golden means","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"s, v = eigen([0 1 0; 0 0 1; 1 0 1])\nGA1 = real(v[1,end] / v[end,end])","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"second one","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"GA2 = real(v[2,end] / v[end,end])","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"set up 3D radial koosh ball trajectory","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"theta = acos.(((0:(nCyc * nFA - 1)) * GA1) .% 1)\nphi = (0:(nCyc * nFA - 1)) * 2 * pi * GA2\n\nk = zeros(3, length(theta))\nk[3,:] = cos.(theta)\nk[2,:] = sin.(theta) .* sin.(phi)\nk[1,:] = sin.(theta) .* cos.(phi)\n\nk = reshape(k, 3, nCyc, nFA)\nk = permutedims(k, (1, 3, 2))\nk = reshape(k, 3, nCyc*nFA);\nnothing #hide","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"Set number of iterations","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"N = 10_000_000","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"initalize with linear order","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"order = Int32.(1:(nCyc*nFA))\norder = reshape(order, nFA, nCyc)","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate initial cost","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"cost(k,order)","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"call simulated annealing algorithm that changes the order in place (as indicated by the ! at the end of the function call)","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"SimulatedAnneling!(k, order, N_iter=N)","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"calculate the final cost","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"cost(k,order)","category":"page"},{"location":"build_literate/tutorial/#Benchmarking","page":"Tutorial","title":"Benchmarking","text":"","category":"section"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"N = 1_000\n@benchmark SimulatedAnneling!($k, $order, N_iter=$N, rng = $(MersenneTwister(12345)))","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MRIeddyCurrentOptimization","category":"page"},{"location":"#MRIeddyCurrentOptimization.jl","page":"Home","title":"MRIeddyCurrentOptimization.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the MRIeddyCurrentOptimization.jl package, which implements ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation of all exported functions can be found in the API Section. ","category":"page"}]
}
