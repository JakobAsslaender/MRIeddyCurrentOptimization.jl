<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MRIeddyCurrentOptimization.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://JakobAsslaender.github.io/MRIeddyCurrentOptimization.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MRIeddyCurrentOptimization.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Tutorial"><span>Tutorial</span></a></li><li><a class="tocitem" href="#Benchmarking"><span>Benchmarking</span></a></li></ul></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JakobAsslaender/MRIeddyCurrentOptimization.jl/blob/master/docs/src/index.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MRIeddyCurrentOptimization.jl"><a class="docs-heading-anchor" href="#MRIeddyCurrentOptimization.jl">MRIeddyCurrentOptimization.jl</a><a id="MRIeddyCurrentOptimization.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MRIeddyCurrentOptimization.jl" title="Permalink"></a></h1><p>Documentation for the <a href="https://github.com/JakobAsslaender/MRIeddyCurrentOptimization.jl">MRIeddyCurrentOptimization.jl</a> package, which implements a simulated annealing algorithm to re-order k-space lines for minimal eddy current artifacts. The approach is describe in detail in the corresponding <a href="https://TODO.url">paper</a>. In the following, we give a brief tutorial. The documentation of all exported functions can be found in the <a href="api/#API">API</a> Section.</p><h2 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h2><p><a href="https://mybinder.org/v2/gh/JakobAsslaender/MRIeddyCurrentOptimization.jl/gh-pages?filepath=dev/build_literate/tutorial.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a></p><p>The main function is <a href="api/#MRIeddyCurrentOptimization.SimulatedAnneling!-Tuple{Any, Any}"><code>SimulatedAnneling!(k, order)</code></a>, which, for a given k-space trajectory <code>k</code>, optimizes the index matrix <code>order</code>. The function randomly chooses a timepoint <code>t</code> of the spin dynamics and, within <code>t</code>, attempts to swap the two random cylce indices <code>c</code> and <code>c̃</code>. If the swap is beneficial, the indices are swapped. In line with the simulated annealing theory, even unbeneficial swaps are performed with a certain probabilty that is comparably high in the first iterations and goes to zero for later iterations. In the following, we explain the interface of the package at the example of the optimization used in the paper where we optimize a 3D radial koosh-ball trajectry.</p><p>For this example, we need the following packages:</p><pre><code class="language-julia hljs">using MRIeddyCurrentOptimization
using BenchmarkTools
using LinearAlgebra
using Random
using Plots</code></pre><p>We define number of time points in our spin dynamics (i.e. the number of RF-pulses)</p><pre><code class="language-julia hljs">Nt = 975;</code></pre><p>as well as the number of cycles that we want to acquire</p><pre><code class="language-julia hljs">Nc = 94;</code></pre><p>Like in the paper, we use the 2D golden means trajectory proposed by <a href="https://doi.org/10.1002/mrm.21837">Chan et al.</a>, which can be calculated with an eigendecomposition. The first golden mean is</p><pre><code class="language-julia hljs">s, v = eigen([0 1 0; 0 0 1; 1 0 1])
ϕ₁ = real(v[1,end] / v[end])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.4655712318767679</code></pre><p>and the second one is</p><pre><code class="language-julia hljs">ϕ₂ = real(v[2,end] / v[end])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.6823278038280193</code></pre><p>With the golden means we calcualte the angles of the k-space spokes:</p><pre><code class="language-julia hljs">θ = acos.(((0:(Nc * Nt - 1)) * ϕ₁) .% 1)
φ = (0:(Nc * Nt - 1)) * 2π * ϕ₂;</code></pre><p>and calculate the k-space trajectory:</p><pre><code class="language-julia hljs">k = zeros(3, length(θ))
k[3,:] = cos.(θ)
k[2,:] = sin.(θ) .* sin.(φ)
k[1,:] = sin.(θ) .* cos.(φ);</code></pre><p>As discussed in the paper, a near-optimal k-space coverage is achieved by binning the first <code>Nc</code> angles into the first time point <code>t₁</code>, the next <code>Nc</code> angles into the second time point <code>t₂</code> and so forth. Hence, we need to permute the dimensions of the k-space trajectory to re-order the spokes:</p><pre><code class="language-julia hljs">k = reshape(k, 3, Nc, Nt)
k = permutedims(k, (1, 3, 2))
k = reshape(k, 3, Nc*Nt);</code></pre><p>Here, we initialize the simulated annealing algorithm with the <em>default</em>, i.e., with a linear ordering scheme:</p><pre><code class="language-julia hljs">order = Int32.(1:(Nc*Nt))
order = reshape(order, Nt, Nc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">975×94 Matrix{Int32}:
   1   976  1951  2926  3901  4876  …  86776  87751  88726  89701  90676
   2   977  1952  2927  3902  4877     86777  87752  88727  89702  90677
   3   978  1953  2928  3903  4878     86778  87753  88728  89703  90678
   4   979  1954  2929  3904  4879     86779  87754  88729  89704  90679
   5   980  1955  2930  3905  4880     86780  87755  88730  89705  90680
   6   981  1956  2931  3906  4881  …  86781  87756  88731  89706  90681
   7   982  1957  2932  3907  4882     86782  87757  88732  89707  90682
   8   983  1958  2933  3908  4883     86783  87758  88733  89708  90683
   9   984  1959  2934  3909  4884     86784  87759  88734  89709  90684
  10   985  1960  2935  3910  4885     86785  87760  88735  89710  90685
   ⋮                             ⋮  ⋱             ⋮                
 967  1942  2917  3892  4867  5842     87742  88717  89692  90667  91642
 968  1943  2918  3893  4868  5843     87743  88718  89693  90668  91643
 969  1944  2919  3894  4869  5844     87744  88719  89694  90669  91644
 970  1945  2920  3895  4870  5845     87745  88720  89695  90670  91645
 971  1946  2921  3896  4871  5846  …  87746  88721  89696  90671  91646
 972  1947  2922  3897  4872  5847     87747  88722  89697  90672  91647
 973  1948  2923  3898  4873  5848     87748  88723  89698  90673  91648
 974  1949  2924  3899  4874  5849     87749  88724  89699  90674  91649
 975  1950  2925  3900  4875  5850     87750  88725  89700  90675  91650</code></pre><p>The cost of this order, with the package&#39;s default cost function (<code>p=3</code>, which is equivalent to <code>p=6</code> in the paper due to an additional squaring, and with <code>w_even=1</code>, i.e., with equal weights on even and odd jumps) is given by</p><pre><code class="language-julia hljs">cost(k,order)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">56903.002202833086</code></pre><p>We can visualize inital cost by plotting a histogram of the Euclidean distances:</p><pre><code class="language-julia hljs">Δk = k[:,order[1:end - 1]] - k[:,order[2:end]]
Δk = vec(reduce(+, Δk.^2, dims=1))
p = histogram(Δk, bins=(0:0.01:1.5), xlabel=&quot;Euclidean distance on the unity sphere&quot;, ylabel=&quot;Number of occurrencess&quot;, label = &quot;default ordering&quot;)</code></pre><object type="text/html" data="../plots/718941308.html" style="width:100%;height:425px;"></object><p>Like in the paper, we use a fixed 1 billion iterations:</p><pre><code class="language-julia hljs">N = 1_000_000_000;</code></pre><p>and we call the simulated annealing algorithm, which changes the matrix <code>order</code> in-place (as indicated by the <code>!</code> at the end of the function call)</p><pre><code class="language-julia hljs">SimulatedAnneling!(k, order, N_iter=N)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">975×94 Matrix{Int32}:
     1  69226  47776  85801  13651  …  73126  44851  40951  32176  35101
 74102  17552  14627  39977  26327     79952  57527  53627  44852  69227
 22428  51678  67278  74103  14628     86778  70203  41928  78978   4878
 10729      4  15604  28279  67279     66304  64354   8779   5854  84829
 84830  34130   9755  40955  61430      1955  12680  42905      5  51680
 73131  68256  43881  72156  28281  …  23406  86781  77031  55581  18531
 39982  16582  38032  20482  80932     44857  35107   3907  28282  89707
 74108  69233  90683  73133   7808     80933  87758  16583  22433  38033
 62409  81909  84834      9   1959     47784  17559  10734  16584   4884
 69235   8785  33160  34135  76060     81910  51685   4885  50710  78985
     ⋮                              ⋱             ⋮                
 39967  31192  72142  15592  25342     66292  38992   5842  79942   4867
 74093    968  60443  89693  77993      1943   5843  39968  28268  38993
 68244  35094   8769  25344  44844     54594  58494  74094  43869  73119
 80920  69220  44845  59470  11695      2920  71170   3895  38020  85795
  7796  63371  11696  53621  45821  …   9746  83846  38021  72146  52646
  1947  51672  18522  47772  39972     87747  32172  50697  66297  19497
 36073  85798  12673  41923  28273     54598  44848  84823  14623  72148
  5849  61424  65324   8774  22424     21449  78974  51674  48749  38999
 18525  55575  13650  21450  56550     34125  27300  85800  42900  91650</code></pre><p>One can appreciate the changed indices in <code>order</code> and we use the same cost function to compute the final cost that is substantially reduced:</p><pre><code class="language-julia hljs">cost(k,order)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">43.17055043543803</code></pre><p>The redueced cost is also reflected in the histogram of the spherical distance:</p><pre><code class="language-julia hljs">Δk = k[:,order[1:end - 1]] - k[:,order[2:end]]
Δk = vec(reduce(+, Δk.^2, dims=1))
histogram!(p, Δk, bins=(0:0.01:1.5), label = &quot;optimized ordering&quot;)</code></pre><object type="text/html" data="../plots/611445892.html" style="width:100%;height:425px;"></object><h2 id="Benchmarking"><a class="docs-heading-anchor" href="#Benchmarking">Benchmarking</a><a id="Benchmarking-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarking" title="Permalink"></a></h2><p>Last but not least, we can benchmark the code and verify that the code is non-allocating:</p><pre><code class="language-julia hljs">N = 1_000
@benchmark SimulatedAnneling!($k, $order, N_iter=$N, rng = $(MersenneTwister(12345)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  126.463 μs …  1.108 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     138.381 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   141.442 μs ± 22.615 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

   ▁ ▄▆▃▆▅▁▇█▅▃▅▅▃▃▂▃▂▂▂▃▂▁▁                                   ▂
  ██▄█████████████████████████▇▇▆▆▇▅▅▆▅▅▅▆▇▆▆▄▅▁▅██▇▆▅▇▆▆▄▄▄▅▆ █
  126 μs        Histogram: log(frequency) by time       196 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 31 October 2021 04:29">Sunday 31 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
