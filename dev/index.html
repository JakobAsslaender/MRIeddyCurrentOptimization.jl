<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MRIeddyCurrentOptimization.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://JakobAsslaender.github.io/MRIeddyCurrentOptimization.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MRIeddyCurrentOptimization.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Tutorial"><span>Tutorial</span></a></li><li><a class="tocitem" href="#Benchmarking"><span>Benchmarking</span></a></li></ul></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JakobAsslaender/MRIeddyCurrentOptimization.jl/blob/master/docs/src/index.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MRIeddyCurrentOptimization.jl"><a class="docs-heading-anchor" href="#MRIeddyCurrentOptimization.jl">MRIeddyCurrentOptimization.jl</a><a id="MRIeddyCurrentOptimization.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MRIeddyCurrentOptimization.jl" title="Permalink"></a></h1><p>Documentation for the <a href="https://github.com/JakobAsslaender/MRIeddyCurrentOptimization.jl">MRIeddyCurrentOptimization.jl</a> package, which implements a simulated annealing algorithm to re-order k-space lines for minimal eddy current artifacts. The approach is describe in detail in the corresponding <a href="https://TODO.url">paper</a>. In the following, we give a brief tutorial. The documentation of all exported functions can be found in the <a href="api/#API">API</a> Section.</p><h2 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h2><p><a href="https://mybinder.org/v2/gh/JakobAsslaender/MRIeddyCurrentOptimization.jl/gh-pages?filepath=dev/build_literate/index.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a></p><p>The main function is <a href="api/#MRIeddyCurrentOptimization.SimulatedAnneling!-Tuple{Any, Any}"><code>SimulatedAnneling!(k, order)</code></a>, which, for a given k-space trajectory <code>k</code>, optimizes the index matrix <code>order</code>. The function randomly chooses a timepoint <code>t</code> of the spin dynamics and, within <code>t</code>, attempts to swap the two random cylce indices <code>c</code> and <code>c̃</code>. If the swap is beneficial, the indices are swapped. In line with the simulated annealing theory, even unbeneficial swaps are performed with a certain probabilty that is comparably high in the first iterations and goes to zero for later iterations. In the following, we explain the interface of the package at the example of the optimization used in the paper where we optimize a 3D radial koosh-ball trajectry.</p><p>For this example, we need the following packages:</p><pre><code class="language-julia hljs">using MRIeddyCurrentOptimization
using BenchmarkTools
using LinearAlgebra
using Random
using Plots</code></pre><p>We define number of time points in our spin dynamics (i.e. the number of RF-pulses)</p><pre><code class="language-julia hljs">Nt = 981;</code></pre><p>as well as the number of cycles that we want to acquire</p><pre><code class="language-julia hljs">Nc = 94;</code></pre><p>Like in the paper, we use the 2D golden means trajectory proposed by <a href="https://doi.org/10.1002/mrm.21837">Chan et al.</a>, which can be calculated with an eigendecomposition. The first golden mean is</p><pre><code class="language-julia hljs">s, v = eigen([0 1 0; 0 0 1; 1 0 1])
ϕ₁ = real(v[1,end] / v[end])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.4655712318767679</code></pre><p>and the second one is</p><pre><code class="language-julia hljs">ϕ₂ = real(v[2,end] / v[end])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.6823278038280193</code></pre><p>With the golden means we calcualte the angles of the k-space spokes:</p><pre><code class="language-julia hljs">θ = acos.(((0:(Nc * Nt - 1)) * ϕ₁) .% 1)
φ = (0:(Nc * Nt - 1)) * 2π * ϕ₂;</code></pre><p>and calculate the k-space trajectory:</p><pre><code class="language-julia hljs">k = zeros(3, length(θ))
k[3,:] = cos.(θ)
k[2,:] = sin.(θ) .* sin.(φ)
k[1,:] = sin.(θ) .* cos.(φ);</code></pre><p>As discussed in the paper, a near-optimal k-space coverage is achieved by binning the first <code>Nc</code> angles into the first time point <code>t₁</code>, the next <code>Nc</code> angles into the second time point <code>t₂</code> and so forth. Hence, we need to permute the dimensions of the k-space trajectory to re-order the spokes:</p><pre><code class="language-julia hljs">k = reshape(k, 3, Nc, Nt)
k = permutedims(k, (1, 3, 2))
k = reshape(k, 3, Nc*Nt);</code></pre><p>Here, we initialize the simulated annealing algorithm with the <em>default</em>, i.e., with a linear ordering scheme:</p><pre><code class="language-julia hljs">order = Int32.(1:(Nc*Nt))
order = reshape(order, Nt, Nc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">981×94 Matrix{Int32}:
   1   982  1963  2944  3925  4906  …  87310  88291  89272  90253  91234
   2   983  1964  2945  3926  4907     87311  88292  89273  90254  91235
   3   984  1965  2946  3927  4908     87312  88293  89274  90255  91236
   4   985  1966  2947  3928  4909     87313  88294  89275  90256  91237
   5   986  1967  2948  3929  4910     87314  88295  89276  90257  91238
   6   987  1968  2949  3930  4911  …  87315  88296  89277  90258  91239
   7   988  1969  2950  3931  4912     87316  88297  89278  90259  91240
   8   989  1970  2951  3932  4913     87317  88298  89279  90260  91241
   9   990  1971  2952  3933  4914     87318  88299  89280  90261  91242
  10   991  1972  2953  3934  4915     87319  88300  89281  90262  91243
   ⋮                             ⋮  ⋱             ⋮                
 973  1954  2935  3916  4897  5878     88282  89263  90244  91225  92206
 974  1955  2936  3917  4898  5879     88283  89264  90245  91226  92207
 975  1956  2937  3918  4899  5880     88284  89265  90246  91227  92208
 976  1957  2938  3919  4900  5881  …  88285  89266  90247  91228  92209
 977  1958  2939  3920  4901  5882     88286  89267  90248  91229  92210
 978  1959  2940  3921  4902  5883     88287  89268  90249  91230  92211
 979  1960  2941  3922  4903  5884     88288  89269  90250  91231  92212
 980  1961  2942  3923  4904  5885     88289  89270  90251  91232  92213
 981  1962  2943  3924  4905  5886  …  88290  89271  90252  91233  92214</code></pre><p>The cost of this order, with the package&#39;s default cost function (<code>p=3</code>, which is equivalent to <code>p=6</code> in the paper due to an additional squaring, and with <code>w_even=1</code>, i.e., with equal weights on even and odd jumps) is given by</p><pre><code class="language-julia hljs">cost(k,order)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">56331.297667687926</code></pre><p>We can visualize inital cost by plotting a histogram of the Euclidean distances:</p><pre><code class="language-julia hljs">Δk = k[:,order[1:end - 1]] - k[:,order[2:end]]
Δk = vec(reduce(+, Δk.^2, dims=1))
p = histogram(Δk, bins=(0:0.01:1.5), xlabel=&quot;Euclidean distance&quot;, ylabel=&quot;Number of occurrencess&quot;, label = &quot;default ordering&quot;)</code></pre><object type="text/html" data="plots/737861251.html" style="width:100%;height:425px;"></object><p>Like in the paper, we use a fixed 1 billion iterations:</p><pre><code class="language-julia hljs">N = 1_000_000_000;</code></pre><p>and we call the simulated annealing algorithm, which changes the matrix <code>order</code> in-place (as indicated by the <code>!</code> at the end of the function call)</p><pre><code class="language-julia hljs">SimulatedAnneling!(k, order, N_iter=N)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">981×94 Matrix{Int32}:
     1  25507  69652  72595  57880  …  61804   3925  52975  51994  41203
 34337  81425  63767  66710  70634      9812  10793    983  64748  53957
 28452  10794  11775  60825      3     22566  63768  53958  80445  88293
 62788  85351  86332  49054  31396     35320  30415   1966   6871  36301
 10796  60827  74561  43169  44150     69656  83390  54941  59846  89276
 85353  82410  22569  31398  78486  …  17664  50037   2949  72600  18645
 33361  36304  35323  25513   7855     30418  84373  15703   1969  31399
 27476  49058  48077    989   1970     64754  13742   9818  36305   3932
 83394  43173  42192  62793  76527     58869  75546  84375  89280  56907
 71623  37288  30421  56908  24535      6877  10801  78490  18649   4915
     ⋮                              ⋱             ⋮                
 66700  46099  57871  54928  42175     75529  62776   2935  67681  16669
 14708  80435  70625  21575  76511     88283  10784  15689  89264  91226
 27462  47082  18633  74550  89265     17652  23538  90246  39234  85341
 21577  41197  71608    976  55912  …  30406  57874  16672  18634  92209
 52970  35312  19616  75533  22559     43160  92210  91229  71609  12749
 47085  29427  72591  69648  75534     55914  58857  60819  65724  78477
 16675  82402   1960  17656  88288     90250   6865  49048  59839  91231
 69650  54935  36296  70631  17657     59840  19619  83384  26486  39239
 63765  89271  70632  37278   5886  …  48069  72594  50031  39240  92214</code></pre><p>One can appreciate the changed indices in <code>order</code> and we use the same cost function to compute the final cost that is substantially reduced:</p><pre><code class="language-julia hljs">cost(k,order)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">44.05603307767917</code></pre><p>The redueced cost is also reflected in the histogram of the spherical distance:</p><pre><code class="language-julia hljs">Δk = k[:,order[1:end - 1]] - k[:,order[2:end]]
Δk = vec(reduce(+, Δk.^2, dims=1))
histogram!(p, Δk, bins=(0:0.01:1.5), label = &quot;Uniform weighting&quot;)</code></pre><object type="text/html" data="plots/368579702.html" style="width:100%;height:425px;"></object><h2 id="Benchmarking"><a class="docs-heading-anchor" href="#Benchmarking">Benchmarking</a><a id="Benchmarking-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarking" title="Permalink"></a></h2><p>Last but not least, we can benchmark the code and verify that the code is non-allocating:</p><pre><code class="language-julia hljs">N = 1_000
@benchmark SimulatedAnneling!($k, $order, N_iter=$N, rng = $(MersenneTwister(12345)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  137.657 μs …  2.282 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     162.969 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   176.860 μs ± 48.087 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

    ▅▇█▄▄▂▁                                                     
  ▅█████████▆▆▅▅▅▅▅▄▄▄▄▃▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃
  138 μs          Histogram: frequency by time          331 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 2 February 2022 18:31">Wednesday 2 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
